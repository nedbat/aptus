* V1

+ License.
+ output filename for aptuscmd.
- Sample .aptus files.
- Doc pages (rst2px?)
+ safeeval or json. (safe_eval)
+ Keys working on Linux.
+ Cursors working on Linux.
+ Cursors for Mac.
+ Mac: use apple-key rather than control.
+ Help.
+ Engine extension should be nested in aptus package.
+ Windows kits pre-built.

* V2
- Decide on re-entrancy, keep things from getting tangled up.
- Combine pointinfo and stats panel, and add more info to it.

* Bugs

+ If client size is queried while minimized, it comes back as zero, and a divide by zero error happens.
+ Proper prompting about overwriting existing files.
+ If you zoom out too far, boundary tracing makes the whole set disappear.
+ Progress can decide there's 0 sec left, and shows an empty string.
+ When dragging the set, chaotic pixels still onscreen shimmer, prob something
    wrong with the half-pixel offset.
+ If the file-save picker says "PNG", and the filename is "foo.aptus", it should
    save as a .aptus file.
+ In continuous mode, there's a stark ring of radius 8 or so.
- Somehow I managed to zoom in then zoom out, and ended up outside the legal
    radius and the set disappeared.

* Speed

- Multi-threaded to use more than one core.
- Faster epsilon comparison for cycle checking (use tricky int operations...)
    - http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm
    - http://lomont.org/Math/Papers/2005/CompareFloat.pdf
- Take some more optimizations from Xaos: http://www.delorie.com/gnu/docs/xaos/xaos_29.html
    - Do iterations in batches of 8 to avoid the bailout comparison.
- Take advantage of symmetry across the x-axis.
- Adaptively choose a number of continuous levels (other than 256) based on the
    actual steps in the palette, etc.
x Optimize boundary.py so we can use it for high iterations
+ Boundary checking in C
- Fracint computes the miniter by running the edges (where the min must be), then
    uses it to skip the bailout check until reaching the miniter.
+ Go through the bitblting python code to see if we can skip some of the steps.
+ A custom coloring endpoint in the engine to replace the multiple numpy operations.
+ When dragging the image, only re-calc the parts that have been exposed.
- When dragging the image, keep parts scrolled off-screen, in case they come back.
+ When resizing the window, do similar pixel-retention as when dragging.

* UI

+ Make a window icon.
- Status bar for progress and stats presentation.
- GUI progress indicator.
+ Paint partial progress in the window.
- Palette editor.
+ Multiple windows.
- Back button
    - with a list of places you've been (with thumbnails).
+ Draggable rectangle in addition to click-to-zoom.
- Open command to load aptus state files.
-   and palette files
- Mac: app icon  (if 'wxMac' in wx.PlatformInfo:)
- Custom bookmarks (like the J key).
+ Help
- Ubuntu: resizing the window tries to recalc as you drag (bad idle handling?)
- Arrow keys for nudging the viewport.

* Beauty

+ HSV palette
- Generalized palette specification
+ Reading GIMP gradients as palettes
- Xaos palette options:
    + Palette shifting
    - Algorithmic palette
+ Rotation (simply store the pixel offsets as dx and dy computed from angle).
+ Continuous coloring (http://linas.org/art-gallery/escape/smooth.html)
+ A palette specification, so the complete specs for a pic can be stored.
+ Try to reduce flicker during palette changing (http://wiki.wxpython.org/index.cgi/DoubleBufferedDrawing)
    When cycling colors, display flashes. (wxWindow::IsDoubleBuffered)
- Add an extra segment to non-cyclic ggr palettes.
- Mirroring non-cyclic palettes.
+ Hue tweaking: [ and ] adjust the hue throughout the current palette.
- Read other palette files:
    - .map (see Gnofract 4D)
    - .cs (see Gnofract 4D)
    - .ugr (see Gnofract 4D)
- More varied palettes.
    
* Power

- Editable parameters for things like cycle checking epsilon.
+ Refactor engine.c so that it defines a class, rather than having all those globals.
+ Command line invocation (refactor a bunch of stuff)
- Multi-precision floats
- Interruptable rendering: write partial counts (and all other state) to a file and restart.
- Save counts in a file so a long compute can then be re-colored easily.

* Knowledge

- Stats: what's the census of iteration counts in the image?
+ Stats: some counters (totaliter) need to be more than 32-bit ints.
+ Better progress reporting for trace_boundary: has to count pixels rather than scanlines.
- Switchable coloring: standard, cycle count, etc.
+ Some way of embedding the mandelbrot parameters into the final .PNG, so it can be recreated.
+ A You-Are-Here mini panel showing the general location you are viewing
+   (maybe more than one step's worth).
+ A point-info panel: current position, iteration count, color, palette entry, etc.

* Safety

- A warning when zooming in so far that the precision fails.
- A warning about too many maxedpoints (iter_limit too low).

* Convenience

- Use ez_setup, or eggs, or something to manage the Python dependencies.

* MVC Model
- main mandelbrot
    - center, rotation
    - diameter
    - size
    - iterlimit, bailout
    - continuous
    - warnings: iter-too-low, precision underflow
- palette
    - colors
    - offset
    - density
- undo stack:
    - parameters
    - thumbnail
- you-are-here

* Done

+ Some kind of progress indicator.
+ Cycle detection
